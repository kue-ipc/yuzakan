/**
 * ModaleDialog
 * モーダルダイアログを表示するクラス
 */

{app, text, type Subscription, type Action, type Dispatch} from hyperapp
* as html from @hyperapp/html
{focus} from @hyperapp/dom

{modalDialog, type ModalButton, type ModalSize, type MoadlFullscreen} from ~/app/modal.civet
Status from ~/common/status.civet
{getBootstrap, type Modal} from ~/common/bs.civet

interface ModalState
  title: string
  status: string | Status
  closable: boolean
  action?: ModalButton
  close?: ModalButton
  messages: string | string[]

export default class ModalDialog
  readonly #id: string
  readonly #fade: boolean
  readonly #scrollable: boolean
  readonly #centered: boolean
  readonly #size: ModalSize
  readonly #fullscreen: MoadlFullscreen

  readonly #modalNode: HTMLElement
  readonly #modal: Modal
  readonly #dispatch: Dispatch<ModalState>

  #result: boolean | string | undefined

  @({
    #id:: string
    #fade:: boolean = false
    #scrollable:: boolean = false
    #centered:: boolean = false
    #size?:: ModalSize
    #fullscreen?:: MoadlFullscreen
  })

    #modalNode = document.createElement("div")
    #modalNode.id = `${#id}-modal`
    #modalNode.classList.add("modal")
    #modalNode.classList.add("fade") if #fade
    #modalNode.setAttribute("tabindex", "-1")
    #modalNode.setAttribute("aria-hidden", "true")

    modalDialogNode := document.createElement("div")
    modalDialogNode.id = `${#id}-modal-dialog`
    modalDialogNode.classList.add("modal-dialog")

    #modalNode.appendChild(modalDialogNode)
    document.body.appendChild(#modalNode)

    #modal = new (getBootstrap().Modal)(#modalNode)

    init := {}
      title: ""
      status: "unknown"
      closable: true
      messages: []
      shwon: false
    view := @@#modalView
    node := modalDialogNode
    // subscriptions := (state) =>
    //   [
    //     ModalDialog.onMessage(#modalNode, #receiveModalMessage)
    //     ModalDialog.onShown(#modalNode, (state) -> [{...state, shown: true}, focus(state.focus)])
    //     ModalDialog.onHidden(#modalNode, (state) -> {...state, shown: false})
    //   ]

    #result = undefined
    #dispatch = app<ModalState>({init, view, node})


  // Views
  #modalView({messages, ...dialogProps}: ModalState)
    modalDialog<ModalState> {
      #id
      #scrollable
      #centered
      #size
      #fullscreen
      ...dialogProps
    }, #modalBody {messages}

  #modalBody({messages:: string | string[]})
    messages = [messages] if messages <? "string"
    html.p {}, text message for each message of messages

  // // fire event
  // fireModalMessage(props)
  //   event = new CustomEvent(ModalDialog.MESSAGE_EVENT, {detail: props})
  //   #modalNode.dispatchEvent(event)

  // Actions
  #showModal(state: ModalState, props: Partial<ModalState>)
    {...state, ...props}

  // show
  showPromise(props: Partial<ModalState> = {})
    #dispatch(#showModal.bind(@), props)

    #result = undefined

    waitModalClose = #waitModalClosePromise()

    // HACK: sett private properties of modal config
    //     <https://github.com/twbs/bootstrap/issues/35664>
    if state.closable
      #modal._config.backdrop = true
      #modal._config.keyboard = true
    else
      #modal._config.backdrop = "static"
      #modal._config.keyboard = false
    #modal.show()

    await waitModalClose

    return #result
  
  hide()
    #modal.hide()

  #waitModalClosePromise(): void
    new Promise<void> (resolve, _reject) =>
      #modalNode.addEventListener "hidden.bs.modal", ->
        resolve()
      , {once: true}

  // modalAction = (state) =>
  //   #result = state.value
  //   [state, #hideModal]

  // hideModal = (_dispatch) => #modal.hide()


  // // Static Methods

  // // Create Subscription
  // @onMessage(node: HtmlElement, action): Subscription
  //   [ModalDialog.listenMessage, {node, action}]
  // @onShown(node, action)
  //   [ModalDialog.listenShown, {node, action}]
  // @onHidden(node, action)
  //   [ModalDialog.listenHidden, {node, action}]

  // // SubscriberFn
  // @listenMessage<S>(dispatch: Dispatch<S>, {node:: HtmlElement, action:: Action<S>}): Unsubscribe
  //   func := (e) -> dispatch(action, e.detail)
  //   node.addEventListener(ModalDialog.MESSAGE_EVENT, func)
  //   -> node.removeEventListener(ModalDialog.MESSAGE_EVENT, func)
  // @listenShown(dispatch, {node, action})
  //   func := -> dispatch(action)
  //   node.addEventListener("shown.bs.modal", func)
  //   -> node.removeEventListener("shown.bs.modal", func)
  // @listenHidden(dispatch, {node, action})
  //   func := -> dispatch(action)
  //   node.addEventListener("hidden.bs.modal", func)
  //   -> node.removeEventListener("hidden.bs.modal", func)
