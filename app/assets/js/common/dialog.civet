/**
 * Dialog
 * ダイアログを表示するクラス
 */

{app, text, type Subscription, type Action, type Dispatch, type ElementVNode, type Dispatchable, type Effecter, type EventActions, type Effect} from hyperapp
* as html from @hyperapp/html
{focus} from @hyperapp/dom

modal, {type ModalButton, type ModalSize, type ModalFullscreen} from ~/app/component/modal.civet
Status from ~/common/status.civet
{getBootstrap, type Modal} from ~/common/bs.civet

interface DialogState
  title: string
  status?: string | Status
  closable?: boolean
  action?: ModalButton
  close?: ModalButton
  effecter?: Effecter<DialogState>
  messages: string | string[]

export default class Dialog
  readonly #id: string
  readonly #fade: boolean
  readonly #scrollable: boolean
  readonly #centered: boolean
  readonly #size: ModalSize
  readonly #fullscreen: ModalFullscreen

  readonly #modalNode: HTMLElement
  readonly #modal: Modal
  readonly #dispatch: Dispatch<DialogState>

  #result: boolean | string | undefined

  @({
    #id:: string
    #fade:: boolean = false
    #scrollable:: boolean = false
    #centered:: boolean = false
    #size?:: ModalSize = "md"
    #fullscreen?:: ModalFullscreen = false
    title:: string = ""
    status?:: string | Status
    closable?:: boolean
    action?:: ModalButton
    close?:: ModalButton
    effecter?:: Effecter<DialogState>
    messages:: string | string[] = ""
  })

    #modalNode = document.createElement("div")
    #modalNode.id = `${#id}-modal`
    // #modalNode.classList.add("modal")
    // #modalNode.classList.add("fade") if #fade
    // #modalNode.setAttribute("tabindex", "-1")
    // #modalNode.setAttribute("aria-hidden", "true")

    // modalDialogNode := document.createElement("div")
    // modalDialogNode.id = `${#id}-modal-dialog`
    // modalDialogNode.classList.add("modal-dialog")

    // #modalNode.appendChild(modalDialogNode)
    document.body.appendChild(#modalNode)

    #modal = new (getBootstrap().Modal)(#modalNode)

    init := {}
      title
      status
      closable
      action
      close
      effecter
      messages
    view := @@#modalView
    node := #modalNode
    // subscriptions := (state) =>
    //   [
    //     ModalDialog.onMessage(#modalNode, #receiveModalMessage)
    //     ModalDialog.onShown(#modalNode, (state) -> [{...state, shown: true}, focus(state.focus)])
    //     ModalDialog.onHidden(#modalNode, (state) -> {...state, shown: false})
    //   ]

    #result = undefined
    #dispatch = app<DialogState>({init, view, node})

  // Views
  #modalView({effecter, messages, ...props}: DialogState): ElementVNode<DialogState>
    modal<DialogState> {
      #id
      #fade
      #scrollable
      #centered
      #size
      #fullscreen
      onclick: ((state) -> [state, effecter]) if effecter?
      ...props
    }, #modalBody {messages}

  #modalBody({messages:: string | string[]}): ElementVNode<DialogState>[]
    messages = [messages] if messages <? "string"
    html.p<DialogState> {}, text message for each message of messages

  // Actions
  #updateState(state: DialogState, props: Partial<DialogState>): Dispatchable<DialogState>
    newState := {...state, ...props}
    // HACK: sett private properties of modal config
    //     <https://github.com/twbs/bootstrap/issues/35664>
    if newState.closable
      (#modal as any)._config.backdrop = true
      (#modal as any)._config.keyboard = true
    else
      (#modal as any)._config.backdrop = "static"
      (#modal as any)._config.keyboard = false

    newState

  // pulbic methods
  update(props: Partial<DialogState>): void
    #dispatch(#updateState.bind(@), props)

  show(props?: Partial<DialogState>): void
    #modal.show()

  hide(): void
    #modal.hide()

  waitHidden(): Promise<void>
    new Promise<void> (resolve, _reject) =>
      #modalNode.addEventListener "hidden.bs.modal", ->
        resolve()
      , {once: true}

  showPromise(props?: Partial<DialogState>): Promise<void>
    @update(props) if props

    @show()
    @waitHidden()
  
  // modalAction = (state) =>
  //   #result = state.value
  //   [state, #hideModal]

  // hideModal = (_dispatch) => #modal.hide()


  // // Static Methods

  // // Create Subscription
  // @onMessage(node: HtmlElement, action): Subscription
  //   [ModalDialog.listenMessage, {node, action}]
  // @onShown(node, action)
  //   [ModalDialog.listenShown, {node, action}]
  // @onHidden(node, action)
  //   [ModalDialog.listenHidden, {node, action}]

  // // SubscriberFn
  // @listenMessage<S>(dispatch: Dispatch<S>, {node:: HtmlElement, action:: Action<S>}): Unsubscribe
  //   func := (e) -> dispatch(action, e.detail)
  //   node.addEventListener(ModalDialog.MESSAGE_EVENT, func)
  //   -> node.removeEventListener(ModalDialog.MESSAGE_EVENT, func)
  // @listenShown(dispatch, {node, action})
  //   func := -> dispatch(action)
  //   node.addEventListener("shown.bs.modal", func)
  //   -> node.removeEventListener("shown.bs.modal", func)
  // @listenHidden(dispatch, {node, action})
  //   func := -> dispatch(action)
  //   node.addEventListener("hidden.bs.modal", func)
  //   -> node.removeEventListener("hidden.bs.modal", func)
