/**
 * Dialog
 * ダイアログを表示するクラス
 */

{app, text, type Dispatch, type ElementVNode, type Dispatchable, type Effecter} from hyperapp
* as html from @hyperapp/html

{modalDialog, type ModalButton, type ModalSize, type ModalFullscreen} from ~/app/component/modal.civet
Status from ~/common/status.civet
{getBootstrap, type Modal} from ~/common/bs.civet

export interface DialogState
  title: string
  status?: string | Status
  closable?: boolean
  action?: ModalButton
  close?: ModalButton
  effecter?: Effecter<DialogState>
  messages: string | string[]

export default class Dialog
  readonly #id: string
  readonly #fade: boolean
  readonly #scrollable: boolean
  readonly #centered: boolean
  readonly #size: ModalSize
  readonly #fullscreen: ModalFullscreen

  readonly #modalNode: HTMLElement
  readonly #modal: Modal
  readonly #dispatch: Dispatch<DialogState>

  @({
    #id:: string
    #fade:: boolean = false
    #scrollable:: boolean = false
    #centered:: boolean = false
    #size?:: ModalSize = "md"
    #fullscreen?:: ModalFullscreen = false
    title:: string = ""
    status?:: string | Status
    closable?:: boolean
    action?:: ModalButton
    close?:: ModalButton
    effecter?:: Effecter<DialogState>
    messages:: string | string[] = ""
  })

    #modalNode = document.createElement("div")
    #modalNode.id = `${#id}-modal`
    #modalNode.classList.add("modal")
    #modalNode.classList.add("fade") if #fade
    #modalNode.setAttribute("tabindex", "-1")
    #modalNode.setAttribute("aria-hidden", "true")

    modalDialogNode := document.createElement("div")
    modalDialogNode.id = `${#id}-modal-dialog`
    modalDialogNode.classList.add("modal-dialog")

    #modalNode.appendChild(modalDialogNode)
    document.body.appendChild(#modalNode)

    init := {}
      title
      status
      closable
      action
      close
      effecter
      messages
    view := @@#modalView
    node := modalDialogNode

    #dispatch = app<DialogState>({init, view, node})
    #modal = new (getBootstrap().Modal)(#modalNode)

  // Views

  #modalView({effecter, messages, ...props}: DialogState): ElementVNode<DialogState>
    modalDialog<DialogState> {
      #id
      #scrollable
      #centered
      #size
      #fullscreen
      onclick: ((state) -> [state, effecter]) if effecter?
      ...props
    }, #modalBody {messages}

  #modalBody({messages:: string | string[]}): ElementVNode<DialogState>[]
    messages = [messages] if messages <? "string"
    html.p<DialogState> {}, text message for each message of messages

  // Actions

  #updateState(state: DialogState, props: Partial<DialogState>): Dispatchable<DialogState>
    newState := {...state, ...props}
    // HACK: sett private properties of modal config
    //     <https://github.com/twbs/bootstrap/issues/35664>
    if newState.closable
      (#modal as any)._config.backdrop = true
      (#modal as any)._config.keyboard = true
    else
      (#modal as any)._config.backdrop = "static"
      (#modal as any)._config.keyboard = false

    newState

  // pulbic methods

  update(props: Partial<DialogState>): void
    #dispatch(#updateState.bind(@), props)

  show(props?: Partial<DialogState>): void
    @update(props) if props?
    console.debug "show modal", #id
    #modal.show()

  hide(): void
    console.debug "hide modal", #id
    #modal.hide()

  waitHidden(): Promise<void>
    new Promise<void> (resolve, _reject) =>
      #modalNode.addEventListener "hidden.bs.modal", ->
        resolve()
      , {once: true}

  showPromise(props?: Partial<DialogState>): Promise<void>
    wait := @waitHidden()
    @show(props)
    wait
