// Login App

{app, text, type Dispatch, type Dispatchable} from hyperapp
* as html from @hyperapp/html
{focus} from @hyperapp/dom
{delay} from @hyperapp/time
APIDialog from ~/api_dialog.civet
bsIcon from ~/app/bs_icon.civet
csrf from ~/csrf.civet
{t} from ~/common/i18n.civet

type LoginState
  username: string??
  password: string??
  disabled: boolean

apiDialog := new APIDialog {
  id: "login"
  name: "actions.login"
  method: "POST"
  path: "session"
  responseMessageCodeList: [
    [201, {status: "success", message: "login_succeeded", redirectTo: "/"}]
    [400, {status: "failure", message: "login_failed"}]
    [422, {status: "failure", message: "login_failed"}]
  ]
}

submittable := ({username, password, disabled}: LoginState) ->
  not disabled and username and password

// Actions

Login := (state: LoginState, event: PointerEvent) ->
  [{...state, disabled: true}, login(state)]

EnterToSubmitOrNextInput := (state: LoginState, event: KeyboardEvent) ->
  if event.keyCode is 13
    if submittable(state)
      [{...state, disabled: true}, login(state)]
    else if event.target? and event.target <? Element and
        event.target.id is "session-username"
      [state, focus("session-password")]
    else
      [state, focus("session-username")]
  else
    state

UpdateUsername := (state: LoginState, event: InputEvent): LoginState ->
  if event.target <? HTMLInputElement
    {...state, username: event.target.value}
  else
    console.warn "username event target is not html input element"
    state

UpdatePassword := (state: LoginState, event: InputEvent): LoginState ->
  if event.target <? HTMLInputElement
    {...state, password: event.target.value}
  else
    console.warn "password event target is not html input element"
    state

// Effecters

runLogin := (dispatch: Dispatch<LoginState>,
  payload: {username: string??, password: string??}) ->
  await apiDialog.submitPromise {data: {...csrf(), ...payload}}
  dispatch (state) -> [
    {...state, disabled: false, password: null}
    focus("session-username")
  ]

// Effect Generators

login := ({username, password, disabled}: LoginState) ->
  [runLogin, {username, password}]

// Views

loginTitle := () ->
  html.h3 {class: "login-title text-center mb-2"}, text t("actions.login")

loginUsernameInput := ({username:: string??, disabled:: boolean}) ->
  html.input {
    id: "session-username"
    class: "form-control"
    type: "text"
    autocomplete: "username"
    required: true
    placeholder: t("view.labels.username")
    disabled
    value: username
    oninput: UpdateUsername
    onkeypress: EnterToSubmitOrNextInput
  }

loginPasswordInput := ({password:: string??, disabled:: boolean}) ->
  html.input {
    id: "session-password"
    class: "form-control"
    type: "password"
    autocomplete: "current-password"
    required: true
    placeholder: t("view.labels.password")
    disabled
    value: password
    oninput: UpdatePassword
    onkeypress: EnterToSubmitOrNextInput
  }

loginSubmitButton := (state: LoginState) ->
  html.button {
    class: "btn btn-primary d-flex align-items-center justify-content-center"
    disabled: not submittable(state)
    onclick: Login
  }, [
    bsIcon {name: "box-arrow-in-right", class: "flex-shrink-0 me-1"}
    text t("actions.login")
  ]

// App

export default loginApp := ->
  node := document.getElementById("login")

  if node?
    classList := Array.from(node.classList)

    init: Dispatchable<LoginState, any>  := [
      {username: null, password: null, disabled: false}
      delay 10, (state: LoginState) -> [state, focus("session-username")]
    ]

    view := (state: LoginState) ->
      html.form {id: "login", class: classList}, [
        loginTitle()
        html.div {class: "mb-3"},
          loginUsernameInput(state.{username, disabled})
        html.div {class: "mb-3"},
          loginPasswordInput(state.{password, disabled})
        html.div {class: "d-grid gap-auto"},
          loginSubmitButton(state)
      ]

    app<LoginState> {init, view, node}
