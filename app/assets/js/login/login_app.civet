// Login app

{app, text, type Dispatch, type Dispatchable} from hyperapp
* as html from @hyperapp/html
{focus} from @hyperapp/dom
{delay} from @hyperapp/time
APIDialog from ~/api_dialog.civet
bsIcon from ~/app/bs_icon.civet
csrf from ~/csrf.civet
{t} from ~/common/i18n.civet
{runAlertFlash} from ~/app/alert.civet

{type Flash, flashValidation, type Validation} from ~/common/flash.civet
{createRunCreateAuth, type AuthProps} from ~api/actions/auth.civet

interface LoginState
  auth: AuthProps
  disabled: boolean
  flash: Flash

interface LoginInputState < Validation
  value: string
  disabled: boolean

LOGIN_ID := "login"
LOGIN_USERNAME_ID := "login-username"
LOGIN_PASSWORD_ID := "login-password"

// fuction

submittable := (state: LoginState): boolean ->
  !(state.disabled or !state.auth.username or !state.auth.password)

// Actions

Login := (state: LoginState, _event: Event) ->
  if submittable(state)
    [{...state, disabled: true}, login(state.auth)]
  else
    state

EnterToSubmitOrNextInput := (state: LoginState, event: KeyboardEvent) ->
  unless event.target <? HTMLInputElement
    console.warn "event target is not html input element"
    return state

  if event.code is "Enter"
    if submittable(state)
      Login
    else if event.target.id is LOGIN_USERNAME_ID
      [state, focus(LOGIN_PASSWORD_ID)]
    else
      [state, focus(LOGIN_USERNAME_ID)]
  else
    state

UpdateUsername := (state: LoginState, event: InputEvent): LoginState ->
  unless event.target <? HTMLInputElement
    console.warn "event target is not html input element"
    return state

  {}
    ...state
    auth: {...state.auth, username: event.target.value}
    flash: {}
      ...state.flash
      valid: {...state.flash?.valid, username: []}
      invalid: {...state.flash?.invalid, username: []}

UpdatePassword := (state: LoginState, event: InputEvent): LoginState ->
  unless event.target <? HTMLInputElement
    console.warn "event target is not html input element"
    return state

  {}
    ...state
    auth: {...state.auth, password: event.target.value}
    flash: {}
      ...state.flash
      valid: {...state.flash?.valid, password: []}
      invalid: {...state.flash?.invalid, password: []}

PreventSubmit := (state: LoginState, event: SubmitEvent): LoginState ->
  event.preventDefault()
  state

// create Effecters
createRunLogin = 

  createRunCreateAuth({action, fallback})

  })
// Effecters

runAfterCreateAuth := (dispatch: Dispatch<LoginState>) ->
  console.debug "run after create auth"
  dispatch (status: LoginState) ->
    [{...status, disbaled: false}, [runAlertFlash, status.flash]]

runLogin := do

// Effect Generators

login := (auth: AuthProps) ->
  [runLogin, auth]

// Views

loginTitle := () ->
  html.h3 {class: "login-title text-center mb-2"}, text t("actions.login")

loginUsernameInput := ({value, disabled, valid, invalid}: LoginInputState) ->
  html.div {class: "mb-3"}, [
    html.input {
      id: LOGIN_USERNAME_ID
      class: ["form-control", {is-valid: valid?#, is-invalid: invalid?#}]
      type: "text"
      autocomplete: "username"
      required: true
      placeholder: t("ui.labels.username")
      disabled
      value
      oninput: UpdateUsername
      onkeypress: EnterToSubmitOrNextInput
    }
    html.div {class: "valid-feedback"},
      text valid?.join("")
    html.div {class: "invalid-feedback"},
      text invalid?.join("")
  ]

loginPasswordInput := ({value, disabled, valid, invalid}: LoginInputState) ->
  html.div {class: "mb-3"}, [
    html.input {
      id: LOGIN_PASSWORD_ID
      class: ["form-control", {is-valid: valid?#, is-invalid: invalid?#}]
      type: "password"
      autocomplete: "current-password"
      required: true
      placeholder: t("ui.labels.password")
      disabled
      value
      oninput: UpdatePassword
      onkeypress: EnterToSubmitOrNextInput
    }
    html.div {class: "valid-feedback"},
      text valid?.join("")
    html.div {class: "invalid-feedback"},
      text invalid?.join("")
  ]

loginSubmitButton := ({auth:: AuthProps, disabled:: boolean}) ->
  html.div {class: "d-grid gap-auto"},
    html.button {
      class: "btn btn-primary d-flex align-items-center justify-content-center"
      disabled: !disabled or !auth.username or !auth.password
      onclick: Login
    }, [
      bsIcon {name: "box-arrow-in-right", class: "flex-shrink-0 me-1"}
      text t("actions.login")
    ]

// App

init: Dispatchable<LoginState> := [
  {}
    auth: {username: "", password: ""}
    flash: {}
    disabled: false
  delay 10, (state: LoginState) -> [state, focus(LOGIN_USERNAME_ID)]
]

view := ({auth, flash, disabled}: LoginState) ->
  html.form {onsubmit: PreventSubmit}, [
    loginTitle()
    loginUsernameInput({value: auth.username, disabled,
      ...flashValidation(flash, "username")})
    loginPasswordInput({value: auth.password, disabled,
      ...flashValidation(flash, "password")})
    loginSubmitButton({auth, disabled: submittable({auth, flash, disabled})})
  ]

export default loginApp := ->
  if node? := document.getElementById(LOGIN_ID)
    console.debug "start login app"
    app<LoginState> {init, view, node}
