/**
 * ApiDialog class
 * データをJSONとしてAPIにfetchし、受け取ったJSONをメッセージとして表示する。
 * 完了するまではmodalを使用して、操作できないようにする。
 */ 

import {app, text} from "hyperapp"
import * as html from "@hyperapp/html"
import {focus} from "@hyperapp/dom"
import {Modal} from "bootstrap"
import {StatusIcon, getStatus} from "~/app/status.civet"
import {fetchJson, Method} from "~api/fetch_json.civet"
import {modalDialog} from "~/app/modal.civet"

type CodeAction = {status: string, message: string, reload?: boolean,
  redirectTo?: string}

export default class APIDialog
  @API_ROOT_PATH: URL := new URL("/api", )

  @MESSAGE_EVENT := "apidialog.message"
  @DEFAULT_CODE_ACTIONS: Map<number, CodeAction> := new Map [
    [200, {status: "success", message: "ok"}]
    [400, {status: "error", message: "bad_request"}]
    [401, {status: "error", message: "unauthorized", reload: true}]
    [403, {status: "error", message: "forbidden", reload: true}]
    [422, {status: "failure", message: "unprocessable_content"}]
    [500, {status: "fatal", message: "internal_server_error", reload: true}]
  ]
  @UNKNOWN_CODE_ACTION: CodeAction := {status: "unknown", message: "unknown"}

  readonly #id: string
  readonly #title: string
  readonly #method: Method
  readonly #path: string
  readonly #codeActions: Map<number, CodeAction>?

  @({#id, #title, #method = "GET", #path, #codeActions}:
    {id: string, title: string, method: Method, path?: string, codeActions?: Map<number, CodeAction>})
    #codeActions = new Map [...DEFAULT_CODE_ACTIONS, ...codeActions]

    @modalNode = document.createElement("div")
    @modalNode.id = `${@id}-modal`
    @modalNode.classList.add("modal")
    @modalNode.setAttribute("tabindex", -1)
    @modalNode.setAttribute("aria-hidden", "true")

    modalDialogNode := document.createElement("div")
    modalDialogNode.id = `${@id}-modal-dialog`
    modalDialogNode.classList.add("modal-dialog", "modal-dialog-centered")

    @modalNode.appendChild(modalDialogNode)
    document.body.appendChild(@modalNode)

    @modal = new Modal(@modalNode)

    app {
      init: {
        status: "unknown"
        title: "no title"
        messages: "n/a"
        closable: true
        link: null
        reload: false
      }
      view: @modalView
      node: modalDialogNode
      subscriptions: (state) => [
        @messageSub @messageAction, {node: @modalNode}
      ]
    }

  #getCodeAction(code)

  messageList({messages})
    messages = [messages] unless messages instanceof Array
    html.div {}, messages.filter((x) -> typeof x is "string").map (msg) ->
      html.div {}, text msg

  modalMessage(state)
    // hack modal config
    // https://github.com/twbs/bootstrap/issues/35664
    if state.closable
      @modal._config.backdrop = true
      @modal._config.keyboard = true
    else
      @modal._config.backdrop = "static"
      @modal._config.keyboard = false

    event := new CustomEvent(APIDialog.MESSAGE_EVENT, {detail: state})
    @modalNode.dispatchEvent(event)

  messageRunner(dispatch, {action, node})
    func := (e) -> dispatch(action, e.detail)
    node.addEventListener(APIDialog.MESSAGE_EVENT, func)
    -> node.removeEventListener(APIDialog.MESSAGE_EVENT, func)

  submitPromise({url = @url, method = @method, data, type})
    @modalMessage {
      status: "running"
      title: `${@title}中`
      messages: `${@title}を実施しています。しばらくお待ち下さい。`
      closable: false
      link: null
      reload: false
    }
    @modal.show()

    response := try
      await fetchJson {url, method, data, type}
    catch error
      console.error error
      {
        ok: false
        code: 0
        type: "json"
        data: {
          message: "サーバー接続時にエラーが発生しました。しばらく待ってから、再度試してください。"
        }
      }

    responseData :=
      switch response.type
        when "json"
          response.data
        when "text"
          {
            message: response.data
          }
        when null, undefined
          {}
        else
          console.error `Unsupported respose type: ${response.type}`
          {
            message: "異常なレスポンスが返されました。再度試してください。"
          }

    codeAction := #codeActions.get(response.code) || APIDialog.UNKNOWN_CODE_ACTION

    messages := [(codeAction.message || responseData.message), ...(responseData.errors ?? [])]
      .filter (v) -> typeof v is "string"

    {consable, link, reload, reloadDelay} :=
      if codeAction?.redirectTo?
        reloadDelay :=
          if codeAction.reloadTime? and codeAction.reloadTime > 0
            messages.push(`約${codeAction.reloadTime}秒後に画面を切り替えます。`)
            codeAction.reloadTime * 1000
          else
            messages.push("画面を切り替えます。しばらくお待ち下さい。")
            0 // default 0 msec
        {
          closable: false
          link: codeAction.redirectTo
          reloadDelay
        }
      else if codeAction?.reload
        {closable: false,link: null, reload: true}
      else
        {closable: true, link: null, reload: false}

    @modalMessage {
      status: codeAction.status
      title: `${@title}${getStatus(codeAction.status).label}`
      messages
      closable
      link
      reload
    }

    if link?
      setTimeout ->
        location.href = link
      , reloadDelay
    else if codeAction?.autoCloseTime
      setTimeout =>
        @modal.hide()
      , codeAction.autoCloseTime * 1000

    await @waitModalClose()

    return response

  modalView = ({status, title, messages, closable, link, reload}) =>
    modalDialog {
      id: @id,
      centered: true
      title
      status
      closable
      action: if link?
        {
          label: "すぐに移動する"
          color: "primary"
          onclick: (state) -> [state, [ -> location.href = link]]
        }
      else if reload
        {
          label: "ページの再読み込み"
          color: "danger"
          onclick: (state) -> [state, [ -> location.reload()]]
        }
    }, @messageList {messages: messages}

  messageSub = (action, {node}) => [@messageRunner, {action, node}]

  messageAction = (state, params) =>
    newState := {...state, ...params}
    if newState.closable
      [newState, focus(`${@id}-modal-close-button`)]
    else
      newState

  waitModalClose = =>
    new Promise (resolve, reject) =>
      @modalNode.addEventListener "hidden.bs.modal", ->
        resolve()
      , {once: true}
