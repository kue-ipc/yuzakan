/**
 * fetchJson
 * APIと連携してデータをJSONで受け取る処理をする。
 */

HttpLinkHeader from http-link-header
{formDataToJson, formDataToUrlencoded} from ~/common/form_helper.civet
{objToJson, objToUrlencoded, toInteger} from ~/common/convert.civet
{extractPagination} from ~api/pagination.civet
type {PaginationParams} from ~api/pagination.civet

export Method ::= "GET" | "HEAD" | "POST" | "PUT" | "PATCH" | "DELETE"

interface RequestParams < RequestInit
  path: string | string[]
  methed?: Method
  data?: {}

interface ResponseData
  ok: boolean
  code: number
  location: string
  type?: "json" | "text"
  data: any
  pagination?: PaginationParams
  links?: HttpLinkHeader

API_URL := new URL("/api", document.baseURI)

export fetchJson := (params: RequestParams) ->
  request := createRequest(params)
  console.debug "fetch request: %s %s", request.method, request.url
  response := await fetch request
  console.debug "fetch response: %d %s", response.status, response.url
  parseResponse(response)

export fetchJsonGet := (params: RequestParams) ->
  fetchJson({...params, method: "GET"})

export fetchJsonHead := (params: RequestParams) ->
  fetchJson({...params, method: "HEAD"})

export fetchJsonPost := (params: RequestParams) ->
  fetchJson({...params, method: "POST"})

export fetchJsonPut := (params: RequestParams) ->
  fetchJson({...params, method: "PUT"})

export fetchJsonPatch := (params: RequestParams) ->
  fetchJson({...params, method: "PATCH"})

export fetchJsonDelete := (params: RequestParams) ->
  fetchJson({...params, method: "DELETE"})

normalizePath := (path: string | string[]) ->
  path = path.split("/") if path <? "string"
  path.map(encodeURIComponent).join("/")

// create request
createRequest := ({path, method = "GET", data = {}, ...params}:
  RequestParams): Request ->
  url := new URL(normalizePath(path), API_URL)
  headers := new Headers {}
    "Accept": "application/json"
  let body
 
  if data?
    switch method
      when "GET", "HEAD"
        query :=
          if data <? "string"
            encodeURIComponent(data)
          else if data <? FormData
            formDataToUrlencoded(data)
          else
            objToUrlencoded(data)
        url.search = query
      when "POST", "PUT", "PATCH", "DELETE"
        body =
          if data <? "string"
            data
          else if data <? FormData
            formDataToJson(data)
          else
            objToJson(data)
        headers.append("Content-Type", "application/json")
        headers.append("Content-Length", body.length.toString())

  init: RequestInit := {}
    method: method
    mode: "same-origin"
    credentials: "same-origin"
    headers
    body
    ...params

  new Request(url, init)

parseResponse := (response: Response) ->
  location := response.headers.get("Content-Location") ?? response.url
  contentType := response.headers.get("Content-Type")
  responseData :=
    if not contentType?
      {data: null}
    else if contentType.startsWith("application/json")
      {type: "json", data: await response.json()}
    else if contentType.startsWith("text/plain")
      {type: "text", data: await response.text()}
    else
      throw new Error(`Unknown or unsupported content type: ${contentType}`)

  contentRange := response.headers.get("Content-Range")
  paginationInfo :=
    if contentRange?
      {pagination: extractPagination(contentRange, location)}
    else
      {}

  linkHeader := response.headers.get("Link")
  linkInfo :=
    if linkHeader?
      {links: HttpLinkHeader.parse(linkHeader)}
    else
      {}

  {
    ok: response.ok
    code: toInteger(response.status)
    location
    ...responseData
    ...paginationInfo
    ...linkInfo
  }
