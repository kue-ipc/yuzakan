// Creator functions for Hyperapp object and fetch api

csrf from ~/csrf.civet

{type Action, type Effecter} from hyperapp

{type Flash} from ~/common/flash.civet

{fetchAPI, type ResponseData, type RequestParams} from ~api/fetch_api.civet
Pagination from ~api/pagination.civet

export interface ResponseState
  id?: string
  location?: string | URL
  csrf?: Record<string, string>
  flash?: Flash
  pagination?: Pagination

export interface ActionFallback<S extends ResponseState, P>
  action: Action<S, P>
  fallback?: Action<S, ResponseData>

export interface RequestProps
  location?: string | URL
  csrf?: Record<string, string>
  pagination?: Pagination

// create Actions

createAction := <S extends ResponseState, P, Q>(
  path: string, actionFallback: ActionFallback<S, P>, params: RequestParam
): Action<S, Q> ->
  responseAction := createResponseAction(path, actionFallback)
  createRequestAction(path, responseAction, params)

// データを受け取るアクションからレスポンスに対応した新しいアクションを作成する。
// エラーでfallbackを実行する。fallbackがなければ、情報のみ反映。
createResponseAction := <S extends ResponseState, P>(
  path: string, {action, fallback}: ActionFallback<S, P>
): Action<S, ResponseData> ->
  runAction: Effecter<S, P> := (dispatch, props) -> dispatch(action, props)
  runFallback: Effecter<S, ResponseData>? := fallback and
    (dispatch, props) -> dispatch(fallback, props)
  
  (state: S, response: ResponseData) ->
    newState: any := 
      {}
        ...state
        location: response.location
        csrf: response.csrf
        flash: response.flash
        pagination: response.pagination

    pathList := response.location.pathname.split("/")
    for each str of path.split("/")
      value := pathList.shift()
      if result := str.match(/^:(\w+)$/)
        newState[result[1]] = value

    if response.ok
      [newState, [runAction, response.data]]
    else if runFallback?
      [newState, [runFallback, response]]
    else
      newState

createRequestAction := <S extends ResponseState, P>(
  path: string, action: Action<S, ResponseData>, params: RequestParams
): Action<S, P> ->

  // effecter := createRunResponse(path, {action, pathKeys, method, ...params})
  
  (state: S, props: P) ->
    data: any .= {...props}

    switch params.method
      when "POST", "PUT", "PATCH", "DELETE"
        data = {...data, ...(state.csrf ?? csrf())}
      when undefined, "GET", "HEAD"
        if state.pagination?
          data = {...data, ...state.pagination.params()}
    
    // if state.id?
    //   data = {...data, id: state.id}

    // data: any .= {...props}
    // realPath .= path
    // for each key of pathKeys ?? []
    //   unless key in props
    //     // do nothing
    //     console.error "given props does not have the property for path: %s", key
    //     return
    //   realPath = realPath.replace(`:${key}`, props[key])
    //   delete data[key]
    
    effecter := createRunResponse(path, {action})

    [state, [effecter, data]]
  

// create Effecter

// レスポンスを直接渡すエフェクターを作成する。
export createRunResponse :=  <S extends ResponseState, P>(path: string,
  {action, ...params}: {action: Action<S, ResponseData>} & RequestParams
): Effecter<S, P & RequestProps> ->
  (dispatch, data: P & RequestProps) ->
    response := await fetchAPI(path, {data, ...params})
    dispatch(action, response)

// TODO: 後です
// // RESTful Resources
// // GET /resources
// export createRunIndex := <S, P extends Record<string, any>>(
//   {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseAction<S, any>({action, fallback})
//     createRunResponse<S, P>({action: responseAction, method: "GET", ...params})

// // GET /resources?page=x&per_page=y
// export createRunIndexWithPage := <S, P extends Record<string, any>>(
//   {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseActionSetPage({action, fallback})
//     createRunResponse({action: responseAction, method: "GET", ...params})

// // GET /resources/:id
// export createRunShowWithId := <S, P extends Record<string, any>>(
//   {action, fallback, idKey = "id", path, ...params}:
//   ActionFallback<S, P> & {idKey?: string} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseAction({action, fallback})
//     path = path.join("/") if path <? Array
//     path = `${path}/:${idKey}` unless path.includes(`:${idKey}`)
//     pathKeys := [idKey]
//     createRunResponse({action: responseAction, path, pathKeys, method: "GET",
//       ...params})

// // POST /resources
// export createRunCreateWithId := <S, P extends Record<string, any>>(
//   {action, fallback, idKey = "id", setId = false, ...params}:
//   ActionFallback<S, P> & {idKey?: string, setId?: boolean} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := if setId
//       createResponseActionSetId({action, fallback, idKey})
//     else
//       createResponseAction({action, fallback})
//     createRunResponse({action: responseAction, method: "POST", ...params})

// // PATCH /resources/:id
// export createRunUpdateWithId := <S, P extends Record<string, any>>(
//   {action, fallback, idKey = "id", setId = false, path, ...params}:
//   ActionFallback<S, P> & {idKey?: string, setId?: boolean} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := if setId
//       createResponseActionSetId({action, fallback, idKey})
//     else
//       createResponseAction({action, fallback})
//     path = path.join("/") if path <? Array
//     path = `${path}/:${idKey}` unless path.includes(`:${idKey}`)
//     pathKeys := [idKey]
//     createRunResponse({action: responseAction, path, pathKeys, method: "PATCH",
//       ...params})

// // DELETE /resources/:id
// export createRunDestroyWithId := <S, P extends Record<string, any>>(
//   {action, fallback, path, idKey = "id", ...params}:
//   ActionFallback<S, P> & {idKey?: string} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseAction({action, fallback})
//     path = path.join("/") if path <? Array
//     path = `${path}/:${idKey}` unless path.includes(`:${idKey}`)
//     pathKeys := [idKey]
//     createRunResponse({action: responseAction, path, pathKeys, method: "DELETE",
//       ...params})

// RESTful Resource
// GET /resource
export createShow := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, undefined> ->
    responseAction := createResponseAction<S, P>({action, fallback})
    createRequestAction<S, undefined>({action: responseAction, method: "GET", ...params})

    createAction<S, undefined>({action: responseAction, method: "GET", ...params})

// POST /resource
export createCreate := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, P> ->
    responseAction := createResponseAction({action, fallback})
    createRequestAction<S, P>({action: responseAction, method: "POST", ...params})

// PATCH /resource
export createUpdate := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, P> ->
    responseAction := createResponseAction({action, fallback})
    createRequestAction<S, P>({action: responseAction, method: "PATCH", ...params})

// DELETE /resource
export createDestroy := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, undefined> ->
    responseAction := createResponseAction({action, fallback})
    createRequestAction<S, undefined>({action: responseAction, method: "DELETE", ...params})
