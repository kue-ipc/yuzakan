// Creator functions for Hyperapp object and fetch api

{type Action, type Effecter} from hyperapp

{fetchAPI, type ResponseData, type RequestParams} from ~api/fetch_api.civet

export interface ResponseState extends Pick<ResponseData,
  "location" | "csrf" | "flash" | "pagination"> 
    id?: string

export interface ActionFallback<S extends ResponseState, P>
  action: Action<S, P>
  fallback?: Action<S, ResponseData>

// create Actions

createAction := <S extends ResponseState, P, Q>(path: string,
  actionFallback: ActionFallback<S, P>, params: Omit<RequestParams, "data"> = {}
): Action<S, Q> ->
  responseAction := createResponseAction(path, actionFallback)
  createRequestAction(path, responseAction, params)

// データを受け取るアクションからレスポンスに対応した新しいアクションを作成する。
// エラーでfallbackを実行する。fallbackがなければ、情報のみ反映。
createResponseAction := <S extends ResponseState, P>(path: string,
  {action, fallback}: ActionFallback<S, P>
): Action<S, ResponseData> ->
  runAction: Effecter<S, P> := (dispatch, props) -> dispatch(action, props)
  runFallback: Effecter<S, ResponseData>? := fallback and
    (dispatch, props) -> dispatch(fallback, props)
  
  (state: S, response: ResponseData) ->
    newState: any := 
      {}
        ...state
        location: response.location
        csrf: response.csrf
        flash: response.flash
        pagination: response.pagination

    resPathList := response.location.pathname.split("/")
    for each pathItem of path.split("/")
      resPathItem := resPathList.shift()
      if pathItem is resPathItem
        // match
      else if result := pathItem.match(/^:(\w+)$/)
        newState[result[1]] = resPathItem
      else
        console.error `do not match response location for"${path}": %s`,
          response.location
        return [state, [runFallback, response]]

    if response.ok
      [newState, [runAction, response.data]]
    else if runFallback?
      [newState, [runFallback, response]]
    else
      newState

// レスポンスを受け取るアクションからリクエストを行う新しいアクションを作成する。
createRequestAction := <S extends ResponseState, P>(path: string,
  action: Action<S, ResponseData>, params: Omit<RequestParams, "data"> = {}
):Action<S, P> ->
  (state: S, props: P) ->
    data: any .= {...props}

    switch params.method
      when "POST", "PUT", "PATCH", "DELETE"
        data = {...data, ...state.csrf}
      when undefined, "GET", "HEAD"
        data = {...data, ...state.pagination?.params()}
    
    reqPathList := []
    for each pathItem of path.split("/")
      if result := pathItem.match(/^:(\w+)$/)
        key := result[1]
        if key in data
          reqPathList.push(data[key])
          delete data[key]
        else
          console.error "given props does not have the property for path: %s",
            key
          return state
    reqPath := reqPathList.join("/")
    effecter := createRunResponse(reqPath, action, params)

    [state, [effecter, data]]

// create Effecter

// レスポンスを直接渡すエフェクターを作成する。
export createRunResponse :=  <S extends ResponseState, P>(url: URL | string,
  action: Action<S, ResponseData>, params: Omit<RequestParams, "data">
): Effecter<S, P> ->
  (dispatch, data: P) ->
    response := await fetchAPI(url, {...params, data})
    dispatch(action, response)

// RESTful Resources
// GET /resources
export createIndex := <S extends ResponseState, P, Q>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, Q> ->
  path := `/api/${name}`
  createAction<S, P, Q>(path, actionFallback, {...params, method: "GET"})

// GET /resources/:id
export createShowWithId := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, {}> ->
  path := `/api/${name}/:id`
  createAction<S, P, {}>(path, actionFallback, {...params, method: "GET"})

// POST /resources
export createCreateWithId := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, P> ->
  path := `/api/${name}/:id`
  requestPath := `/api/${name}`
  responseAction := createResponseAction(path, actionFallback)
  createRequestAction(requestPath, responseAction, {...params, method: "POST"})

// PATCH /resources/:id
export createRunUpdateWithId := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, P> ->
  path := `/api/${name}/:id`
  createAction<S, P, P>(path, actionFallback, {...params, method: "PATCH"})

// DELETE /resources/:id
export createRunDestroyWithId := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, P> ->
  path := `/api/${name}/:id`
  createAction<S, P, P>(path, actionFallback, {...params, method: "DELETE"})

// RESTful Resource
// GET /resource
export createShow := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, {}> ->
  path := `/api/${name}`
  createAction<S, P, {}>(path, actionFallback, {...params, method: "GET"})

// POST /resource
export createCreate := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, P> ->
  path := `/api/${name}`
  createAction<S, P, P>(path, actionFallback, {...params, method: "POST"})

// PATCH /resource
export createUpdate := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, P> ->
  path := `/api/${name}`
  createAction<S, P, P>(path, actionFallback, {...params, method: "PATCH"})

// DELETE /resource
export createDestroy := <S extends ResponseState, P>(name: string,
  actionFallback: ActionFallback<S, P>,
  params: Omit<RequestParams, "method" | "data"> = {}
): Action<S, {}> ->
  path := `/api/${name}`
  createAction<S, P, {}>(path, actionFallback, {...params, method: "DELETE"})
