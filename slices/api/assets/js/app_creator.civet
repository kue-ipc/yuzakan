// Creator functions for Hyperapp object and fetch api

csrf from ~/csrf.civet

{type Action, type Effecter} from hyperapp

{type Flash} from ~/common/flash.civet

{fetchAPI, type ResponseData, type RequestParams} from ~api/fetch_api.civet
Pagination from ~api/pagination.civet

export interface ResponseState
  id?: string
  location?: string | URL
  csrf?: Record<string, string>
  flash?: Flash
  pagination?: Pagination

export interface ActionFallback<S extends ResponseState, P>
  action: Action<S, P>
  fallback?: Action<S, ResponseData>

// create Actions

// データを受け取るアクションからレスポンスに対応した新しいアクションを作成する。
// エラーでfallbackを実行する。fallbackがなければ、情報のみ反映。
createResponseAction := <S extends ResponseState, P>(
  {action, fallback, setId = false}: ActionFallback<S, P> & {setId?: boolean}):
  Action<S, ResponseData> ->
    runAction: Effecter<S, P> := (dispatch, props) -> dispatch(action, props)
    runFallback: Effecter<S, ResponseData>? := fallback and
      (dispatch, props) -> dispatch(fallback, props)
    (state: S, response: ResponseData) ->
      newState: any := 
        {}
          ...state
          location: response.location
          csrf: response.csrf
          flash: response.flash
          pagination: response.pagination
      if setId
        last := response.location.pathname.split("/").reverse().find((_) -> _)
        newState["id"] = last

      if response.ok
        [newState, [runAction, response.data]]
      else if runFallback?
        [newState, [runFallback, response]]
      else
        newState

createRequestAction := <S extends ResponseState, P>(
  {action, pathKeys, path, method, ...params}:
    {action: Action<S, ResponseData>, pathKeys?: string[]} & RequestParams
): Action<S, P> ->
  effecter: Effecter<S, any> := (dispatch, props) ->
    data: any .= {...props}
    path = path.join("/") if path <? Array
    for each key of pathKeys ?? []
      unless key in props
        // do nothing
        console.error "given props does not have the property for path: %s", key
        return
      path = path.replace(`:${key}`, props[key])
      delete data[key]

    response := await fetchAPI({method, path, data, ...params})
    dispatch(action, response)

  (state: S, props: P) ->
    data: any .= {...props}
    if method? and ["POST", "PUT", "PATCH", "DELETE"].includes(method)
      data = {...data, ...(state.csrf ?? csrf())}
    else if state.pagination? and (!method? or ["POST", "HEAD"].includes(method))
      data = {...data, ...state.pagination.params()}
    
    if state.id?
      data = {...data, id: state.id}

    [state, [effecter, data]]
  

// // create Effecter

// // レスポンスを直接渡すエフェクターを作成する。
// // pathKeys内の文字列はそれぞれ部分文字列になっていはいけない。
// export createRunResponse := <S, P extends Record<string, any>>(
//   {action, pathKeys, path, data, method, ...params}:
//   {action: Action<S, ResponseData>, pathKeys?: string[]} & RequestParams):
//   Effecter<S, P> ->
//     (dispatch, props: P) ->
//       path = path.join("/") if path <? Array
//       for each key of pathKeys ?? []
//         unless key in props
//           // do nothing
//           console.error "given props does not have the property for path: %s", key
//           return
//         path = path.replace(`:${key}`, props[key])

//       data = {...data, ...props}
//       if method? and ["POST", "PUT", "PATCH", "DELETE"].includes(method)
//         data = {...data, ...csrf()}

//       response := await fetchAPI({method, path, data, ...params})
//       dispatch(action, response)

// TODO: 後です
// // RESTful Resources
// // GET /resources
// export createRunIndex := <S, P extends Record<string, any>>(
//   {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseAction<S, any>({action, fallback})
//     createRunResponse<S, P>({action: responseAction, method: "GET", ...params})

// // GET /resources?page=x&per_page=y
// export createRunIndexWithPage := <S, P extends Record<string, any>>(
//   {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseActionSetPage({action, fallback})
//     createRunResponse({action: responseAction, method: "GET", ...params})

// // GET /resources/:id
// export createRunShowWithId := <S, P extends Record<string, any>>(
//   {action, fallback, idKey = "id", path, ...params}:
//   ActionFallback<S, P> & {idKey?: string} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseAction({action, fallback})
//     path = path.join("/") if path <? Array
//     path = `${path}/:${idKey}` unless path.includes(`:${idKey}`)
//     pathKeys := [idKey]
//     createRunResponse({action: responseAction, path, pathKeys, method: "GET",
//       ...params})

// // POST /resources
// export createRunCreateWithId := <S, P extends Record<string, any>>(
//   {action, fallback, idKey = "id", setId = false, ...params}:
//   ActionFallback<S, P> & {idKey?: string, setId?: boolean} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := if setId
//       createResponseActionSetId({action, fallback, idKey})
//     else
//       createResponseAction({action, fallback})
//     createRunResponse({action: responseAction, method: "POST", ...params})

// // PATCH /resources/:id
// export createRunUpdateWithId := <S, P extends Record<string, any>>(
//   {action, fallback, idKey = "id", setId = false, path, ...params}:
//   ActionFallback<S, P> & {idKey?: string, setId?: boolean} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := if setId
//       createResponseActionSetId({action, fallback, idKey})
//     else
//       createResponseAction({action, fallback})
//     path = path.join("/") if path <? Array
//     path = `${path}/:${idKey}` unless path.includes(`:${idKey}`)
//     pathKeys := [idKey]
//     createRunResponse({action: responseAction, path, pathKeys, method: "PATCH",
//       ...params})

// // DELETE /resources/:id
// export createRunDestroyWithId := <S, P extends Record<string, any>>(
//   {action, fallback, path, idKey = "id", ...params}:
//   ActionFallback<S, P> & {idKey?: string} & RequestParams):
//   Effecter<S, P> ->
//     responseAction := createResponseAction({action, fallback})
//     path = path.join("/") if path <? Array
//     path = `${path}/:${idKey}` unless path.includes(`:${idKey}`)
//     pathKeys := [idKey]
//     createRunResponse({action: responseAction, path, pathKeys, method: "DELETE",
//       ...params})

// RESTful Resource
// GET /resource
export createShow := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, undefined> ->
    responseAction := createResponseAction<S, P>({action, fallback})
    createRequestAction<S, undefined>({action: responseAction, method: "GET", ...params})

// POST /resource
export createCreate := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, P> ->
    responseAction := createResponseAction({action, fallback})
    createRequestAction<S, P>({action: responseAction, method: "POST", ...params})

// PATCH /resource
export createUpdate := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, P> ->
    responseAction := createResponseAction({action, fallback})
    createRequestAction<S, P>({action: responseAction, method: "PATCH", ...params})

// DELETE /resource
export createDestroy := <S extends ResponseState, P>(
  {action, fallback, ...params}: ActionFallback<S, P> & RequestParams):
  Action<S, undefined> ->
    responseAction := createResponseAction({action, fallback})
    createRequestAction<S, undefined>({action: responseAction, method: "DELETE", ...params})
