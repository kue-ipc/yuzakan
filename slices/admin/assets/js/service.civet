// path: /admin/services/:name
// node: service

{text, app} from hyperapp
* as html from @hyperapp/html
{fetchAPIGet} from ~api/fetch_api.civet
{formName, formId} from ~/helpers/form_helper.civet
csrf from ~/common/csrf.civet

APIDialog from ~/common/api_dialog.civet
ConfirmDialog from ~/app/confirm_dialog.civet

adapterParams from ~admin/adapter_params.civet

parentNames := ["service"]

abilities := [
  {name: "readable", label: "読み取り"}
  {name: "writable", label: "書き込み"}
  {name: "authenticatable", label: "認証"}
  {name: "password_changeable", label: "パスワード変更"}
  {name: "lockable", label: "ロック"}
]

destroyConfirm := new ConfirmDialog {
  id: formId("destroy", ["modal", "confirm", ...parentNames])
  status: "alert"
  title: "プロバイダーの削除"
  messages: ["プロバイダーを削除してもよろしいですか？"]
  action: {
    color: "danger"
    label: "削除"
  }
}

createAPIDialog := new APIDialog {
  id: formId("create", ["modal", "web", ...parentNames])
  title: "プロバイダーの作成"
  method: "POST"
  url: "/api/services"
  codeActions: new Map [
    [201, {status: "success", message: "プロバイダーを作成しました。"}]
  ]
}

updateAPIDialog := new APIDialog {
  id: formId("update", ["modal", "web", ...parentNames])
  title: "プロバイダーの更新"
  method: "PATCH"
  codeActions: new Map [
    [200, {status: "success", message: "プロバイダーを更新しました。"}]
  ]
}

destroyAPIDialog := new APIDialog {
  id: formId("destroy", ["modal", "web", ...parentNames])
  title: "プロバイダーの削除"
  method: "DELETE"
  codeActions: new Map [
    [200, {status: "success", message: "プロバイダーを削除しました。", redirectTo: "/admin/services", reloadTime: 10}]
  ]
}

adapterParamAction := (state, {name, value}) ->
  {...state, service: {...state.service, params: {...state.service.params, [name]: value}}}

serviceAction := (state, {name, service}) ->
  history.pushState(null, null, `/admin/services/${name}`) if name? && name is not state.name

  newState := {}
    ...state
    name: name ?? state.name
    service: {...state.service, ...service}

  return newState unless service.adapter?

  for each adapter of state.adapters when adapter.name is service.adapter
    return newState if adapter.param_types?
    break

  [
    newState
    [showAdapterRunner, {name: service.adapter}]
  ]

adapterAction := (state, {name, adapter}) ->
  name ?= adapter.name
  adapters := for each current of state.adapters
    if current.name is adapter.name
      {...current, ...adapter}
    else
      current
  {...state, adapters}

showAdapterRunner := (dispatch, {name}) ->
  return unless name?

  response := await fetchAPIGet({url: `/api/adapters/${name}`})
  if response.ok
    dispatch(adapterAction, {name: name, adapter: response.data})
  else
    console.error response

createServiceRunner := (dispatch, {service}) ->
  response := await createAPIDialog.submitPromise {data: {...csrf(), ...service}}
  if response.ok
    service := response.data
    dispatch(serviceAction, {name: service.name, service})
  else
    console.error response


updateServiceRunner := (dispatch, {name, service}) ->
  response := await updateAPIDialog.submitPromise {url: `/api/services/${name}`, data: {...csrf(), ...service}}
  if response.ok
    service := response.data
    dispatch(serviceAction, {name: service.name, service})
  else
    console.error response

destroyServiceRunner := (dispatch, {name}) ->
  confirm := await destroyConfirm.showPromise({message: `属性「${name}」を削除してもよろしいですか？`})
  if confirm
    response := await destroyAPIDialog.submitPromise {url: `/api/services/${name}`, data: csrf()}
    if response.ok
      // ...redirect
    else
      console.error response


showServiceRunner := (dispatch, {name}) ->
  return unless name?

  response := await fetchAPIGet({url: `/api/services/${name}`})
  if response.ok
    dispatch(serviceAction, {service: response.data})
  else
    console.error response

initAllAdaptersAction := (state, {adapters}) ->
  {...state, adapters}

indexAllAdaptersRunner := (dispatch) ->
  response := await fetchAPIGet({url: "/api/adapters"})
  if response.ok
    dispatch(initAllAdaptersAction, {adapters: response.data})
  else
    console.error response

name := location.pathname.split("/").at(-1)
name := undefined if name is "*"

init := [
  {name, service: {params: {}}, adapters: []}
  [indexAllAdaptersRunner]
  [showServiceRunner, {name}]
]

view := ({name, service, adapters}) ->
  service_adapter := (adapter for each adapter of adapters when adapter.name is service.adapter)[0]
  html.div {}, [
    html.div {class: "mb-3"}, [
      html.label {class: "form-label", for: "service-name"}, text "名前"
      html.input {
        id: "service-name", class: "form-control", type: "text", required: true, value: service.name
        oninput: (state, event) -> [serviceAction, {service: {name: event.target.value}}]
      }
    ]
    html.div {class: "mb-3"}, [
      html.label {class: "form-label", for: "service-label"}, text "表示名"
      html.input {
        id: "service-label", class: "form-control", type: "text", required: true, value: service.label
        oninput: (state, event) -> [serviceAction, {service: {label: event.target.value}}]
      }
    ]
    html.div {}, [
      html.label {class: "form-label"}, text "可能な操作"
      html.br {}
      (abilities.map (ability) ->
        html.div {class: "form-check form-check-inline"}, [
          html.input {
            id: `service-${ability.name}`, class: "form-check-input", type: "checkbox"
            checked: service[ability.name]
            onchange: (state, event) -> [serviceAction, {service: {[ability.name]: !service[ability.name]}}]
          }
          html.label {class: "form-check-label", for: `service-${ability.name}`}, text ability.label
        ]
      )...
    ]
    html.div {class: "form-check"}, [
      html.input {
        id: `service-individual_password`, class: "form-check-input", type: "checkbox"
        checked: service.individual_password
        onchange: (state, event) -> [serviceAction, {service: {individual_password: !service.individual_password}}]
      }
      html.label {class: "form-check-label", for: `service-individual_password`}, text "パスワード個別設定"
      html.span {class: "ms-1 form-text"}, text "複数プロバイダー一括でのパスワード変更やリセットの対象になりません。"
    ]
    html.div {class: "form-check"}, [
      html.input {
        id: `service-self_management`, class: "form-check-input", type: "checkbox"
        checked: service.self_management
        onchange: (state, event) -> [serviceAction, {service: {self_management: !service.self_management}}]
      }
      html.label {class: "form-check-label", for: `service-self_management`}, text "自己管理可能"
      html.span {class: "ms-1 form-text"}, text "ユーザー自身が登録やパスワードリセット等ができるようになります。"
    ]
    html.div {class: "form-check"}, [
      html.input {
        id: `service-group`, class: "form-check-input", type: "checkbox"
        checked: service.group
        onchange: (state, event) -> [serviceAction, {service: {group: !service.group}}]
      }
      html.label {class: "form-check-label", for: `service-group`}, text "グループ"
      html.span {class: "ms-1 form-text"}, text "グループの取得やメンバーの変更ができるようになります。(アダプターによっては対応していません。)"
    ]
    html.div {class: "mb-3"}, [
      html.label {class: "form-label", for: "service-adapter"}, text "アダプター"
      html.select {
        id: "service-adapter", class: "form-select"
        oninput: (state, event) -> [serviceAction, {service: {adapter: event.target.value}}]
      },
        if service.adapter?
          for each adapter of adapters
            html.option {value: adapter.name, selected: adapter.name is service.adapter}, text adapter.label
        else
          [
            html.option {selected: true}, text "選択してください。"
            ...(for each adapter of adapters
              html.option {value: adapter.name, selected: adapter.name is service.adapter}, text adapter.label
            )
          ]
    ]
    adapterParams {
      params: service.params
      param_types: service_adapter?.param_types ?? []
      action: adapterParamAction
    }
    html.div {class: "mb-1"},
      if !name?
        [
          html.button {
            class: "btn btn-primary"
            onclick: (state) -> [state, [createServiceRunner, {service}]]
          }, text "作成"
        ]
      else
        [
          html.button {
            class: "btn btn-warning"
            onclick: (state) -> [state, [updateServiceRunner, {name, service}]]
          }, text "更新"
          html.button {
            class: "ms-1 btn btn-danger"
            onclick: (state) -> [state, [destroyServiceRunner, {name}]]
          }, text "削除"
        ]
  ]

node := document.getElementById("service")

app {init, view, node}
